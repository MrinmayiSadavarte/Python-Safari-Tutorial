# Python-Safari-Tutorial
Python 3 Object-oriented Programming Second Edition : Author - Dusty Phillips

This repository contains the case studies from each of the following chapters of the Python tutorial.

Tutorial includes formal principles of object-oriented programming and how Python leverages them, Python's idiosyncratic applications of these principles by learning how they are applied to a variety of Python's built-in functions, and design patterns.

Chapter 1: Object-oriented Design, covers important object-oriented concepts. It deals mainly with terminology such as abstraction, classes, encapsulation, and inheritance. We also briefly look at UML to model our classes and objects.

Chapter 2: Objects in Python, discusses classes and objects and how they are used in Python. We will learn about attributes and behaviors on Python objects, and also the organization of classes into packages and modules. Lastly, we will see how to protect our data.

Chapter 3: When Objects Are Alike, gives us a more in-depth look into inheritance. It covers multiple inheritance and shows us how to extend built-ins. This chapter also covers how polymorphism and duck typing work in Python.

Chapter 4: Expecting the Unexpected, looks into exceptions and exception handling. We will learn how to create our own exceptions and how to use exceptions for program flow control.

Chapter 5: When to Use Object-oriented Programming, deals with creating and using objects. We will see how to wrap data using properties and restrict data access. This chapter also discusses the DRY principle and how not to repeat code.

Chapter 6: Python Data Structures, covers the object-oriented features of Python's built-in classes. We'll cover tuples, dictionaries, lists, and sets, as well as a few more advanced collections. We'll also see how to extend these standard objects.

Chapter 7: Python Object-oriented Shortcuts, as the name suggests, deals with time-savers in Python. We will look at many useful built-in functions such as method overloading using default arguments. We'll also see that functions themselves are objects and how this is useful.

Chapter 8: Strings and Serialization, looks at strings, files, and formatting. We'll discuss the difference between strings, bytes, and bytearrays, as well as various ways to serialize textual, object, and binary data to several canonical representations.

Chapter 9: The Iterator Pattern, introduces us to the concept of design patterns and covers Python's iconic implementation of the iterator pattern. We'll learn about list, set, and dictionary comprehensions. We'll also demystify generators and coroutines.

Chapter 10: Python Design Patterns I, covers several design patterns, including the decorator, observer, strategy, state, singleton, and template patterns. Each pattern is discussed with suitable examples and programs implemented in Python.

Chapter 11: Python Design Patterns II, wraps up our discussion of design patterns with coverage of the adapter, facade, flyweight, command, abstract, and composite patterns. More examples of how idiomatic Python code differs from canonical implementations are provided.

Chapter 12: Testing Object-oriented Programs, opens with why testing is so important in Python applications. It emphasizes test-driven development and introduces two different testing suites: unittest and py.test. Finally, it discusses mocking test objects and code coverage.

Chapter 13: Concurrency, is a whirlwind tour of Python's support (and lack thereof) of concurrency patterns. It discusses threads, multiprocessing, futures, and the new AsyncIO library.
